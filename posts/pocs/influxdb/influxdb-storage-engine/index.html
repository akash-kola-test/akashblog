<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>InfluxDB Storage Engine | Akash´s corner</title>
<meta name="keywords" content="influxdb">
<meta name="description" content="Shards
Basically data is organized into shards of time, each is an underlying DB which makes it efficient to drop old data

Organizing data in a key value store
Basically each series and field maps to a unique ID as seen in the below picture

We can arrange the data with key as ID and time, and the value being the field value and the key is always sorted">
<meta name="author" content="">
<link rel="canonical" href="https://akash-kola-test.github.io/akashblog/posts/pocs/influxdb/influxdb-storage-engine/">
<link crossorigin="anonymous" href="/akashblog/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://akash-kola-test.github.io/akashblog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://akash-kola-test.github.io/akashblog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://akash-kola-test.github.io/akashblog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://akash-kola-test.github.io/akashblog/apple-touch-icon.png">
<link rel="mask-icon" href="https://akash-kola-test.github.io/akashblog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://akash-kola-test.github.io/akashblog/posts/pocs/influxdb/influxdb-storage-engine/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://akash-kola-test.github.io/akashblog/posts/pocs/influxdb/influxdb-storage-engine/">
  <meta property="og:site_name" content="Akash´s corner">
  <meta property="og:title" content="InfluxDB Storage Engine">
  <meta property="og:description" content="Shards Basically data is organized into shards of time, each is an underlying DB which makes it efficient to drop old data
Organizing data in a key value store Basically each series and field maps to a unique ID as seen in the below picture
We can arrange the data with key as ID and time, and the value being the field value and the key is always sorted">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-11-29T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-29T00:00:00+00:00">
    <meta property="article:tag" content="Influxdb">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="InfluxDB Storage Engine">
<meta name="twitter:description" content="Shards
Basically data is organized into shards of time, each is an underlying DB which makes it efficient to drop old data

Organizing data in a key value store
Basically each series and field maps to a unique ID as seen in the below picture

We can arrange the data with key as ID and time, and the value being the field value and the key is always sorted">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://akash-kola-test.github.io/akashblog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "InfluxDB Storage Engine",
      "item": "https://akash-kola-test.github.io/akashblog/posts/pocs/influxdb/influxdb-storage-engine/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "InfluxDB Storage Engine",
  "name": "InfluxDB Storage Engine",
  "description": "Shards Basically data is organized into shards of time, each is an underlying DB which makes it efficient to drop old data\nOrganizing data in a key value store Basically each series and field maps to a unique ID as seen in the below picture\nWe can arrange the data with key as ID and time, and the value being the field value and the key is always sorted\n",
  "keywords": [
    "influxdb"
  ],
  "articleBody": "Shards Basically data is organized into shards of time, each is an underlying DB which makes it efficient to drop old data\nOrganizing data in a key value store Basically each series and field maps to a unique ID as seen in the below picture\nWe can arrange the data with key as ID and time, and the value being the field value and the key is always sorted\nMany storage engines have this model for example Level DB, LMDB, and other key values stores. But still they won’t give all necessary features needed for time series data.\nIssues with Level DB For implementing InfluxDB storage engine, Level DB has following issues\ndeletes are expensive too many open file handles Issues with LMDB Implementation For implementing InfluxDB storage engine, LM DB implementations has following issues\nwrite throughput no compression InfluxDB’s Storage Engine (Time Structured Merge tree - TSM) It’s almost similar to how LSM Trees works, also compression will happen based on data types. Here is typical write workflow that happens with incoming time series:\nwrite the incoming time series data to the WAL write that also to the in memory data structure and send the write successful response periodically in memory data flushes to the TSM files InfluxDB’s Storage Engine (Inverted Index) Here is the sample query which we need to execute on our storage engine\nWe will use the inverted index to map the incoming query as series search, like every series will have it’s unique ID and we need maintain what fields does each measurement is having, also we need store what tag keys’ having it as values, and the posting lists which will store the IDs that were under the specific measurements, tags values as specified in the picture. This way we will which IDs we needed from out data structure to query\nThis data will needs to in memory so that we can quickly know what IDs fall under a query, so for this again we will use the same LSM tree structure. And when booting up it will read the entire disk data structure and fill up the in memory index.\n",
  "wordCount" : "357",
  "inLanguage": "en",
  "datePublished": "2024-11-29T00:00:00Z",
  "dateModified": "2024-11-29T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://akash-kola-test.github.io/akashblog/posts/pocs/influxdb/influxdb-storage-engine/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Akash´s corner",
    "logo": {
      "@type": "ImageObject",
      "url": "https://akash-kola-test.github.io/akashblog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://akash-kola-test.github.io/akashblog/" accesskey="h" title="Akash´s corner (Alt + H)">Akash´s corner</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://akash-kola-test.github.io/akashblog/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://akash-kola-test.github.io/akashblog/posts" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://akash-kola-test.github.io/akashblog/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://akash-kola-test.github.io/akashblog/contact" title="Contact">
                    <span>Contact</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      InfluxDB Storage Engine
    </h1>
    <div class="post-meta"><span title='2024-11-29 00:00:00 +0000 UTC'>November 29, 2024</span>

</div>
  </header> 
  <div class="post-content"><h2 id="shards">Shards<a hidden class="anchor" aria-hidden="true" href="#shards">#</a></h2>
<p>Basically data is organized into shards of time, each is an underlying DB which makes it efficient to drop old data</p>
<p><img alt="Shards" loading="lazy" src="/akashblog/images/Shards.png"></p>
<h2 id="organizing-data-in-a-key-value-store">Organizing data in a key value store<a hidden class="anchor" aria-hidden="true" href="#organizing-data-in-a-key-value-store">#</a></h2>
<p>Basically each series and field maps to a unique ID as seen in the below picture</p>
<p><img alt="Series and fields" loading="lazy" src="/akashblog/images/Series%20and%20fields.png"></p>
<p>We can arrange the data with key as ID and time, and the value being the field value and the key is always sorted</p>
<p><img alt="Ordered Key Space Example" loading="lazy" src="/akashblog/images/Ordered%20Key%20Space%20Example.png"></p>
<p>Many storage engines have this model for example <a href="https://github.com/google/leveldb">Level DB</a>, <a href="https://en.wikipedia.org/wiki/Lightning_Memory-Mapped_Database">LMDB</a>, and other key values stores. But still they won&rsquo;t give all necessary features needed for time series data.</p>
<h2 id="issues-with-level-db">Issues with Level DB<a hidden class="anchor" aria-hidden="true" href="#issues-with-level-db">#</a></h2>
<p>For implementing InfluxDB storage engine, Level DB has following issues</p>
<ul>
<li>deletes are expensive</li>
<li>too many open file handles</li>
</ul>
<h2 id="issues-with-lmdb-implementation">Issues with LMDB Implementation<a hidden class="anchor" aria-hidden="true" href="#issues-with-lmdb-implementation">#</a></h2>
<p>For implementing InfluxDB storage engine, LM DB implementations has following issues</p>
<ul>
<li>write throughput</li>
<li>no compression</li>
</ul>
<h2 id="influxdbs-storage-engine-time-structured-merge-tree---tsm">InfluxDB&rsquo;s Storage Engine (Time Structured Merge tree - TSM)<a hidden class="anchor" aria-hidden="true" href="#influxdbs-storage-engine-time-structured-merge-tree---tsm">#</a></h2>
<p>It&rsquo;s almost similar to how LSM Trees works, also compression will happen based on data types. Here is typical write workflow that happens with incoming time series:</p>
<ul>
<li>write the incoming time series data to the WAL</li>
<li>write that also to the in memory data structure and send the write successful response</li>
<li>periodically in memory data flushes to the TSM files</li>
</ul>
<p><img alt="TSM Components" loading="lazy" src="/akashblog/images/TSM%20Components.png"></p>
<h2 id="influxdbs-storage-engine-inverted-index">InfluxDB&rsquo;s Storage Engine (Inverted Index)<a hidden class="anchor" aria-hidden="true" href="#influxdbs-storage-engine-inverted-index">#</a></h2>
<p>Here is the sample query which we need to execute on our storage engine</p>
<p><img alt="Example Query" loading="lazy" src="/akashblog/images/Example%20Query.png"></p>
<p>We will use the inverted index to map the incoming query as series search, like every series will have it&rsquo;s unique ID and we need maintain what fields does each measurement is having, also we need store what tag keys&rsquo; having it as values, and the posting lists which will store the IDs that were under the specific measurements, tags values as specified in the picture. This way we will which IDs we needed from out data structure to query</p>
<p><img alt="Inverted Index Idea" loading="lazy" src="/akashblog/images/Inverted%20Index%20Idea.png"></p>
<p>This data will needs to in memory so that we can quickly know what IDs fall under a query, so for this again we will use the same LSM tree structure. And when booting up it will read the entire disk data structure and fill up the in memory index.</p>
<p><img alt="Inverted Index Maintainance" loading="lazy" src="/akashblog/images/Inverted%20Index%20Maintainance.png"></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://akash-kola-test.github.io/akashblog/tags/influxdb/">Influxdb</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://akash-kola-test.github.io/akashblog/">Akash´s corner</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
